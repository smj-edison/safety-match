// @flow
import type { Is, IsCompat, Return } from "flown";

// Utility types start
type If<X: boolean, Then, Else = empty> = $Call<
  ((true, Then, Else) => Then) & ((false, Then, Else) => Else),
  X,
  Then,
  Else
>;

type FuncWithZeroArgs = (...args: []) => any;
type FuncWith1Arg = <A>(A) => any;
type FuncWith2Args = <A, B>(A, B) => any;
type FuncWith3Args = <A, B, C>(A, B, C) => any;
type FuncWith4Args = <A, B, C, D>(A, B, C, D) => any;
type FuncWith5Args = <A, B, C, D, E>(A, B, C, D, E) => any;

type Arg1of1<SomeFunc> = $Call<<A, F: (A) => any>(F) => A & A, SomeFunc>;

type Arg1of2<SomeFunc> = $Call<<A, B, F: (A, B) => any>(F) => A & A, SomeFunc>;
type Arg2of2<SomeFunc> = $Call<<A, B, F: (A, B) => any>(F) => B & B, SomeFunc>;

type Arg1of3<SomeFunc> = $Call<
  <A, B, C, F: (A, B, C) => any>(F) => A & A,
  SomeFunc
>;
type Arg2of3<SomeFunc> = $Call<
  <A, B, C, F: (A, B, C) => any>(F) => B & B,
  SomeFunc
>;
type Arg3of3<SomeFunc> = $Call<
  <A, B, C, F: (A, B, C) => any>(F) => C & C,
  SomeFunc
>;

type Arg1of4<SomeFunc> = $Call<
  <A, B, C, D, F: (A, B, C, D) => any>(F) => A & A,
  SomeFunc
>;
type Arg2of4<SomeFunc> = $Call<
  <A, B, C, D, F: (A, B, C, D) => any>(F) => B & B,
  SomeFunc
>;
type Arg3of4<SomeFunc> = $Call<
  <A, B, C, D, F: (A, B, C, D) => any>(F) => C & C,
  SomeFunc
>;
type Arg4of4<SomeFunc> = $Call<
  <A, B, C, D, F: (A, B, C, D) => any>(F) => D & D,
  SomeFunc
>;

type Arg1of5<SomeFunc> = $Call<
  <A, B, C, D, E, F: (A, B, C, D, E) => any>(F) => A & A,
  SomeFunc
>;
type Arg2of5<SomeFunc> = $Call<
  <A, B, C, D, E, F: (A, B, C, D, E) => any>(F) => B & B,
  SomeFunc
>;
type Arg3of5<SomeFunc> = $Call<
  <A, B, C, D, E, F: (A, B, C, D, E) => any>(F) => C & C,
  SomeFunc
>;
type Arg4of5<SomeFunc> = $Call<
  <A, B, C, D, E, F: (A, B, C, D, E) => any>(F) => D & D,
  SomeFunc
>;
type Arg5of5<SomeFunc> = $Call<
  <A, B, C, D, E, F: (A, B, C, D, E) => any>(F) => E & E,
  SomeFunc
>;
// Utility types end

import { type None, none } from "./none";

export { none };
export type { None };

export type MemberType<
  TaggedUnionT: {
    __member_type_this_is_only_here_for_flow_not_at_runtime_dont_use_this: any,
  }
> = $PropertyType<
  TaggedUnionT,
  "__member_type_this_is_only_here_for_flow_not_at_runtime_dont_use_this"
>;

type DefObjSuper = { [key: string]: None | ((...args: any) => any) };

type ExtractReturnType = <V>((...args: any) => V) => V;
// Don't ask
type ReturnOf<T> = $PropertyType<
  $ObjMap<{ focus: T }, ExtractReturnType>,
  "focus"
>;

// prettier-ignore
type DataMapWithNones<DefObj: DefObjSuper> = $ObjMap<DefObj, <V>(V) =>
  If<Is<V, None>,
    None,
    ReturnOf<V>
  >
>;

type DataMap<DefObj: DefObjSuper> = $ObjMap<
  DataMapWithNones<DefObj>,
  <V>(V) => If<Is<V, None>, typeof undefined, V>
>;

type DataWithNonesForKey<DefObj: DefObjSuper, Key> = $ElementType<
  DataMapWithNones<DefObj>,
  Key
>;

// prettier-ignore
type CasesObjFull<DefObj: DefObjSuper, Ret> = $ObjMapi<
  DataMapWithNones<DefObj>,
  <K, V>(K, V) =>
    If<Is<DataWithNonesForKey<DefObj, K>, None>,
      () => Ret,
      (data: DataWithNonesForKey<DefObj, K>) => Ret
    >
>;

type Partial<T> = $Rest<T, {}>;

type CasesObjPartialWithDefault<DefObj: DefObjSuper, Ret> = {|
  ...Partial<CasesObjFull<DefObj, Ret>>,
  _: (data: $Values<DataMap<DefObj>>) => Ret,
|};

class TaggedUnionImpl {
  type: any;
  data: any;

  constructor(MatchType: any, data: any) {
    this.type = MatchType;
    this.data = data;
  }

  match(casesObj: any): any {
    const data = this.data;
    const matchingHandler = casesObj[this.type];

    if (matchingHandler) {
      return matchingHandler(data);
    } else if (casesObj._) {
      return casesObj._(data);
    } else {
      throw new Error(`Match did not handle case: '${this.type}'`);
    }
  }
}

interface TaggedUnionMember<DefObj: DefObjSuper> {
  match: <
    Ret,
    // The object you pass in to match must either include a key for every tag
    // in the tagged union, or include the key `_` to handle all unspecified tags.
    CasesObj:
      | CasesObjFull<DefObj, Ret>
      | CasesObjPartialWithDefault<DefObj, Ret>
  >(
    cases: CasesObj
  ) => Ret;
  type: $Keys<DefObj>;
  data: $Values<DataMap<DefObj>>;
}

opaque type TAGGED_UNIONS_WHOSE_CONSTRUCTORS_TAKE_LESS_THAN_ONE_OR_MORE_THAN_5_ARGUMENTS_ARE_NOT_SUPPORTED_WITH_FLOW = (
  ...args: any
) => any;

// prettier-ignore
type DefObjToTaggedUnionMapper<DefObj: DefObjSuper> = <V>(V) =>
  If<Is<V, None>,
    TaggedUnionMember<DefObj>,
    If<IsCompat<V, FuncWith1Arg>,
      (arg1: Arg1of1<V>) => TaggedUnionMember<DefObj>,
      If<IsCompat<V, FuncWith2Args>,
        (arg1: Arg1of2<V>, arg2: Arg2of2<V>) => TaggedUnionMember<DefObj>,
        If<IsCompat<V, FuncWith3Args>,
          (arg1: Arg1of3<V>, arg2: Arg2of3<V>, arg3: Arg3of3<V>) => TaggedUnionMember<DefObj>,
          If<IsCompat<V, FuncWith4Args>,
            (arg1: Arg1of4<V>, arg2: Arg2of4<V>, arg3: Arg3of4<V>, arg4: Arg4of4<V>) => TaggedUnionMember<DefObj>,
            If<IsCompat<V, FuncWith5Args>,
              (arg1: Arg1of5<V>, arg2: Arg2of5<V>, arg3: Arg3of5<V>, arg4: Arg4of5<V>, arg5: Arg5of5<V>) => TaggedUnionMember<DefObj>,
              TAGGED_UNIONS_WHOSE_CONSTRUCTORS_TAKE_LESS_THAN_ONE_OR_MORE_THAN_5_ARGUMENTS_ARE_NOT_SUPPORTED_WITH_FLOW,
            >
          >
        >
      >
    >
  >;

type TaggedUnion<DefObj: DefObjSuper> = {
  ...$ObjMap<DefObj, DefObjToTaggedUnionMapper<DefObj>>,
  __member_type_this_is_only_here_for_flow_not_at_runtime_dont_use_this: TaggedUnionMember<DefObj>,
  __datamap_for_testing_flow_not_here_at_runtime_do_not_use_this: DataMap<DefObj>,
  __datamap_with_nones_for_testing_flow_not_here_at_runtime_do_not_use_this: DataMapWithNones<DefObj>,
};

export function makeTaggedUnion<T: DefObjSuper>(defObj: T): TaggedUnion<T> {
  type DefObj = typeof defObj;

  type TaggedUnion<DefObj: DefObjSuper> = {
    ...$ObjMap<
      DefObj,
      <V>(
        V
      ) => If<
        Is<V, None>,
        // $FlowIgnore
        TaggedUnionMember<DefObj>,
        If<
          IsCompat<V, FuncWith1Arg>,
          (arg1: Arg1of1<V>) => TaggedUnionMember<DefObj>,
          If<
            IsCompat<V, FuncWith2Args>,
            (arg1: Arg1of2<V>, arg2: Arg2of2<V>) => TaggedUnionMember<DefObj>,
            If<
              IsCompat<V, FuncWith3Args>,
              (
                arg1: Arg1of3<V>,
                arg2: Arg2of3<V>,
                arg3: Arg3of3<V>
              ) => TaggedUnionMember<DefObj>,
              If<
                IsCompat<V, FuncWith4Args>,
                (
                  arg1: Arg1of4<V>,
                  arg2: Arg2of4<V>,
                  arg3: Arg3of4<V>,
                  arg4: Arg4of4<V>
                ) => TaggedUnionMember<DefObj>,
                If<
                  IsCompat<V, FuncWith5Args>,
                  (
                    arg1: Arg1of5<V>,
                    arg2: Arg2of5<V>,
                    arg3: Arg3of5<V>,
                    arg4: Arg4of5<V>,
                    arg5: Arg5of5<V>
                  ) => TaggedUnionMember<DefObj>,
                  TAGGED_UNIONS_WHOSE_CONSTRUCTORS_TAKE_LESS_THAN_ONE_OR_MORE_THAN_5_ARGUMENTS_ARE_NOT_SUPPORTED_WITH_FLOW
                >
              >
            >
          >
        >
      >
    >,
    __member_type_this_is_only_here_for_flow_not_at_runtime_dont_use_this: TaggedUnionMember<DefObj>,
  };

  // $FlowIgnore
  const matchObj: TaggedUnion<T> = {};

  Object.keys(defObj).forEach((matchType) => {
    const value = defObj[matchType];

    if (typeof value === "function") {
      // $FlowIgnore
      matchObj[matchType] = (...args: any) => {
        const data = value(...args);
        return new TaggedUnionImpl(matchType, data);
      };
    } else {
      // $FlowIgnore
      matchObj[matchType] = new TaggedUnionImpl(matchType);
    }
  });

  // $FlowIgnore
  return matchObj;
}
